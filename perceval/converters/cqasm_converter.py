# MIT License
#
# Copyright (c) 2024 Quandela
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# As a special exception, the copyright holders of exqalibur library give you
# permission to combine exqalibur with code included in the standard release of
# Perceval under the MIT license (or modified versions of such code). You may
# copy and distribute such a combined system following the terms of the MIT
# license for both exqalibur and Perceval. This exception for the usage of
# exqalibur is limited to the python bindings used by Perceval.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from perceval.components import Processor, Source
from perceval.components import Circuit, BS, PS, PERM
from .abstract_converter import AGateConverter

import cqasm.v3x as cqasm
import numpy as np


# A collection of gates for which meaningful optical circuits (beam splitter,
# phase shifter, permutation) exist.
# Source:
# https://qutech-delft.github.io/cQASM-spec/language_specification/instructions/gates.html#standard-gate-set
_CQASM_1_QUBIT_GATES = {
    "H": Circuit(2, name="H") // BS.H(),

    # TODO: Something seems to be wrong with the RX rotation, we need
    # to flip the angle to get the same results as qiskit/cirq
    "X": Circuit(2, name="X") // PERM([1, 0]),
    "X90": Circuit(2, name="Rx(π / 2)") // BS.Rx(theta=-np.pi / 2),
    "mX90": Circuit(2, name="Rx(-π / 2)") // BS.Rx(theta=np.pi / 2),
    "Rx": lambda theta: Circuit(2, name=f"Rx({theta})") // BS.Rx(theta=-theta),

    "Y": Circuit(2, name="Y") // PERM([1, 0]) // (1, PS(np.pi / 2)) // (0, PS(-np.pi / 2)),
    "Y90": Circuit(2, name="Ry(π / 2)") // BS.Ry(theta=np.pi / 2),
    "mY90": Circuit(2, name="Ry(-π / 2)") // BS.Ry(theta=-np.pi / 2),
    "Ry": lambda theta: Circuit(2, name=f"Ry({theta})") // BS.Ry(theta=theta),

    "S": Circuit(2, name="S") // (1, PS(np.pi / 2)),
    "Sdag": Circuit(2, name="Sdag") // (1, PS(-np.pi / 2)),
    "T": Circuit(2, name="T") // (1, PS(np.pi / 4)),
    "Tdag": Circuit(2, name="Tdag") // (1, PS(-np.pi / 4)),

    "Z": Circuit(2, name="Z") // (1, PS(-np.pi)),
    "Rz": lambda theta: Circuit(2, name="Rz({theta})") // (0, PS(-theta)) // (1, PS(theta)),
}

_CQASM_2_QUBIT_GATES = {
    "CNOT", "CZ"
}


def _cs(s: str) -> str:
    r"""A shortcut to cleanup the strings generated by the qASM parser"""
    return s[2:-1]


class ConversionSyntaxError(Exception):
    pass


class ConversionUnsupportedFeatureError(Exception):
    pass


class CQASMConverter(AGateConverter):
    r"""cQASM quantum circuit to perceval processor converter.

    :param catalog: a component library to use for the conversion. It must contain CNOT gates.
    :param backend_name: backend name used in the converted processor (default SLOS)
    :param source: the source used as input for the converted processor (default perfect source).
    """
    def __init__(self, catalog, backend_name: str = "SLOS", source: Source = Source()):
        super().__init__(catalog, backend_name, source)

        self._qubit_list = []
        self._num_cnots = 0
        self._use_postselection = False

    def count_qubits(self, ast) -> int:
        return len(self._qubit_list)

    def _collect_qubit_list(self, ast):
        self._qubit_list = []
        for variable in ast.variables:
            if type(variable.typ) is cqasm.types.QubitArray:
                for i in range(variable.typ.size):
                    self._qubit_list.append((_cs(variable.name), i))
            elif type(variable.typ) is cqasm.types.Qubit:
                self._qubit_list.append((_cs(variable.name), -1))
            else:
                raise ConversionUnsupportedFeatureError(f"Classical variable { variable.name } not supported")

    def _operand_to_qubit_indices(self, operand):
        if type(operand) is cqasm.values.VariableRef:
            name = _cs(operand.variable.name)
            qubits = [self._qubit_list.index((name, -1))]
        elif type(operand) is cqasm.values.IndexRef:
            name = _cs(operand.variable.name)
            qubits = [self._qubit_list.index((name, index.value))
                      for index in operand.indices]
        else:
            raise ConversionUnsupportedFeatureError(f"Cannot map variable { name } to a declared qubit")
        return qubits

    def _convert_statement(self, statement):
        gate_name = _cs(statement.name)
        num_operands = len(statement.operands)

        # For now, assume the statement pattern is OP q
        targets = self._operand_to_qubit_indices(statement.operands[0])
        controls = []
        parameter = None

        # Match other statement patterns
        if num_operands == 2:
            if type(statement.operands[1]) is cqasm.values.ConstFloat:
                # Statement pattern is OP(r) q
                parameter = statement.operands[1].value
            else:
                # Statement pattern is OP q, q
                controls = targets
                targets = self._operand_to_qubit_indices(statement.operands[1])
        elif num_operands == 3:
            # Statement is OP(r) q, q
            controls = targets
            targets = self._operand_to_qubit_indices(statement.operands[1])
            parameter = statement.operands[2].value

        num_controls = len(controls)
        # print(gate_name, controls, targets)
        if num_controls >= 2:
            raise ConversionUnsupportedFeatureError(
                f"Gate { gate_name } has more than one control (n = { num_controls })")

        if not controls:
            circuit_template = _CQASM_1_QUBIT_GATES[gate_name]
            if not circuit_template:
                raise ConversionUnsupportedFeatureError(
                    f"Unsupported 1-qubit gate { gate_name }")
            if parameter:
                circuit_template = circuit_template(parameter)
            for target in targets:
                circuit = circuit_template.copy()
                self._converted_processor.add(target * 2, circuit.copy())
        else:
            if gate_name not in _CQASM_2_QUBIT_GATES:
                raise ConversionUnsupportedFeatureError(
                    f"Unsupported 2-qubit gate { gate_name }")
            for target in targets:
                self._create_2_qubit_gates_from_catalog(
                    gate_name,
                    self._num_cnots,
                    controls[0] * 2,
                    target * 2,
                    min(target, controls[0]) * 2,
                    self._use_postselection)

    def convert(self, ast, use_postselection: bool = True) -> Processor:
        r"""Convert a cQASM quantum program into a `Processor`.

        :param ast: the AST of a cQASM program
        :type ast: a Program object, as returned by the cQASM parser
        :param use_postselection: when True, uses a `postprocessed CNOT`
        as the last gate. Otherwise, uses only `heralded CNOT`
        :return: the converted processor
        """
        if not type(ast) is cqasm.semantic.Program:
            raise ConversionSyntaxError(f"cQASM parser error: { ast[0] }")

        self._collect_qubit_list(ast)
        self._num_cnots = sum(
            _cs(s.name) == "CNOT" for s in ast.block.statements)
        self._use_postselection = use_postselection

        qubit_names = [
            f'{ q }[{ i }]' if i >= 0 else q for (q, i) in self._qubit_list]
        self._configure_processor(ast, qubit_names=qubit_names)
        for statement in ast.block.statements:
            self._convert_statement(statement)
        self.apply_input_state()
        return self._converted_processor

    def convert_string(
            self,
            source_string: str,
            use_postselection: bool = True) -> Processor:
        r"""Convert a cQASM quantum program into a `Processor`.

        :param source_string: The cQASM program stored in a string
        :param use_postselection: when True, uses a `postprocessed CNOT`
        as the last gate. Otherwise, uses only `heralded CNOT`
        :return: the converted processor
        """
        ast = cqasm.Analyzer().analyze_string(source_string)
        return self.convert(ast, use_postselection)

    def convert_file(
            self,
            source_file_name: str,
            use_postselection: bool = False) -> Processor:
        r"""Convert a cQASM quantum program into a `Processor`.

        :param source_file_name: The path to the cQASM program to load
        :param use_postselection: when True, uses a `postprocessed CNOT`
        as the last gate. Otherwise, uses only `heralded CNOT`
        :return: the converted processor
        """
        ast = cqasm.Analyzer().analyze_file(source_file_name)
        return self.convert(ast, use_postselection)
